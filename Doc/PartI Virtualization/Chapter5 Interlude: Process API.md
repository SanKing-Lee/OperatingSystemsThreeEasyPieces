# Interlude: Process API
1. **fork()**
   进程|开始位置|fork返回值
   -|-|-|
   父进程|main|子进程的PID
   子进程|fork()|=0
   1. 父进程和子进程有同样的代码。
   2. 父进程从main开始执行而子进程从fork()(包括fork()))执行。
   3. 父进程执行fork()创建一个子进程并返回子进程的PID，而子进程执行fork()只会返回一个0。
   4. 子进程复制了父进程的堆栈，不会与父进程共用同样的堆栈。
   5. question
      1. 子进程如何创建它自己的子进程
      2. 子进程如何判断哪个fork应该返回0还是创建一个新的子进程
   6. answer
      1. 在子进程的执行代码，也就是fork之后返回值为0的代码段再次fork
2. **wait()**
   功能|等待子进程执行完毕然后继续执行
   返回值|执行完毕的子进程的PID
   1. 可以用来保证子进程总是比父进程先执行
   2. question
      1. 如果fork了多个子进程，wait是等待哪一个子进程。
3. **exec**
   1. 从传入的可执行文件中加载代码和静态数据覆盖当前的代码和静态数据，同时重新初始化堆栈和内存空间。
   2. 成功则无返回值
4. **fork和exec的分离**
   1. 把fork和exec分离开来有助于在它们之间完成一些准备工作，比如重定向输出流到文件。
   2. 终端的命令执行也是一个fork和exec的过程。